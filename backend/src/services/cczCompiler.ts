import archiver from 'archiver'
import { createWriteStream, mkdirSync } from 'fs'
import { join } from 'path'
import { tmpdir } from 'os'
import { randomUUID } from 'crypto'

/**
 * Compiles HQ import JSON into a .ccz archive for mobile deployment.
 * Generates suite.xml, profile.ccpr, app_strings.txt, and adds case blocks to XForms.
 */
export class CczCompiler {

  async compile(hqJson: Record<string, any>, appName: string): Promise<string> {
    const modules: any[] = hqJson.modules || []
    const attachments: Record<string, string> = hqJson._attachments || {}

    // Generate all CCZ files
    const files: Record<string, string> = {}

    files['profile.ccpr'] = this.generateProfile(appName)
    files['media_suite.xml'] = '<?xml version="1.0"?>\n<suite version="1"/>'

    const appStrings: Record<string, string> = { 'app.name': appName }
    const suiteEntries: string[] = []
    const suiteMenus: string[] = []
    const suiteDetails: string[] = []
    const suiteResources: string[] = []

    for (let mIdx = 0; mIdx < modules.length; mIdx++) {
      const mod = modules[mIdx]
      const modName = mod.name?.en || `Module ${mIdx}`
      const caseType = mod.case_type || ''
      const forms: any[] = mod.forms || []

      appStrings[`modules.m${mIdx}`] = modName

      // Case detail definitions (if module uses cases)
      if (caseType) {
        appStrings['case_list_title'] = appStrings['case_list_title'] || `${modName}`
        appStrings['case_name_header'] = appStrings['case_name_header'] || 'Name'

        suiteDetails.push(this.generateDetail(`m${mIdx}_case_short`, 'short', mod.case_details?.short?.columns || []))
        suiteDetails.push(this.generateDetail(`m${mIdx}_case_long`, 'long', mod.case_details?.long?.columns || []))

        // Add column headers to app_strings
        const columns = mod.case_details?.short?.columns || []
        for (const col of columns) {
          const headerKey = `m${mIdx}_${col.field}_header`
          appStrings[headerKey] = col.header?.en || col.field
        }
      }

      const menuCommands: string[] = []

      for (let fIdx = 0; fIdx < forms.length; fIdx++) {
        const form = forms[fIdx]
        const formName = form.name?.en || `Form ${fIdx}`
        const xmlns = form.xmlns || ''
        const uniqueId = form.unique_id || ''
        const requires = form.requires || 'none'
        const cmdId = `m${mIdx}-f${fIdx}`
        const filePath = `modules-${mIdx}/forms-${fIdx}.xml`

        appStrings[`forms.m${mIdx}f${fIdx}`] = formName

        // Get the clean XForm from _attachments and add case blocks
        let xform = attachments[`${uniqueId}.xml`] || ''
        if (xform && caseType) {
          xform = this.addCaseBlocks(xform, form.actions, caseType)
        }
        files[filePath] = xform

        // Resource declaration
        suiteResources.push(
          `  <xform>\n    <resource id="${filePath}" version="1">\n      <location authority="local">./${filePath}</location>\n    </resource>\n  </xform>`
        )

        // Entry
        let entry = `  <entry>\n    <form>${xmlns}</form>\n    <command id="${cmdId}">\n      <text><locale id="forms.m${mIdx}f${fIdx}"/></text>\n    </command>`

        if (requires === 'case' && caseType) {
          entry += `\n    <instance id="casedb" src="jr://instance/casedb"/>`
          entry += `\n    <session>\n      <datum id="case_id" nodeset="instance('casedb')/casedb/case[@case_type='${caseType}'][@status='open']" value="./@case_id" detail-select="m${mIdx}_case_short"/>\n    </session>`
        }

        entry += `\n  </entry>`
        suiteEntries.push(entry)
        menuCommands.push(`    <command id="${cmdId}"/>`)
      }

      suiteMenus.push(
        `  <menu id="m${mIdx}">\n    <text><locale id="modules.m${mIdx}"/></text>\n${menuCommands.join('\n')}\n  </menu>`
      )
    }

    // Build suite.xml
    const localeResource = `  <locale language="default">\n    <resource id="app_strings" version="1">\n      <location authority="local">./default/app_strings.txt</location>\n    </resource>\n  </locale>`

    files['suite.xml'] = `<?xml version="1.0"?>\n<suite version="1">\n${suiteResources.join('\n')}\n${localeResource}\n${suiteDetails.join('\n')}\n${suiteEntries.join('\n')}\n${suiteMenus.join('\n')}\n</suite>`

    // Build app_strings.txt
    files['default/app_strings.txt'] = Object.entries(appStrings)
      .map(([k, v]) => `${k}=${v}`)
      .join('\n')

    // Package into CCZ
    return this.packageCcz(files, appName)
  }

  private generateProfile(appName: string): string {
    return `<?xml version="1.0"?>
<profile xmlns="http://cihi.commcarehq.org/jad"
         version="1"
         uniqueid="${randomUUID()}"
         name="${this.escapeXml(appName)}"
         update="http://localhost/update">
  <property key="CommCare App Name" value="${this.escapeXml(appName)}"/>
  <property key="cc-content-version" value="1"/>
  <property key="cc-app-version" value="1"/>
  <features>
    <users active="true"/>
  </features>
  <suite>
    <resource id="suite" version="1" descriptor="Suite Definition">
      <location authority="local">./suite.xml</location>
    </resource>
  </suite>
  <suite>
    <resource id="media-suite" version="1" descriptor="Media Suite Definition">
      <location authority="local">./media_suite.xml</location>
    </resource>
  </suite>
</profile>`
  }

  private generateDetail(id: string, display: string, columns: any[]): string {
    if (columns.length === 0 && display === 'long') {
      return `  <detail id="${id}">\n    <title><text><locale id="case_list_title"/></text></title>\n  </detail>`
    }

    const fields = columns.map((col: any) => {
      const field = col.field || 'name'
      const header = col.header?.en || field
      return `    <field>\n      <header><text><locale id="${id}_${field}_header"/></text></header>\n      <template><text><xpath function="${field}"/></text></template>\n    </field>`
    })

    // Always include case_name as first field if not already present
    if (!columns.some((c: any) => c.field === 'name' || c.field === 'case_name')) {
      fields.unshift(
        `    <field>\n      <header><text><locale id="case_name_header"/></text></header>\n      <template><text><xpath function="case_name"/></text></template>\n    </field>`
      )
    }

    return `  <detail id="${id}">\n    <title><text><locale id="case_list_title"/></text></title>\n${fields.join('\n')}\n  </detail>`
  }

  /** Add case blocks back into an XForm based on form actions (for mobile runtime). */
  private addCaseBlocks(xform: string, actions: any, caseType: string): string {
    if (!actions) return xform

    const openCase = actions.open_case
    const updateCase = actions.update_case
    const isCreate = openCase?.condition?.type === 'always'
    const isUpdate = updateCase?.condition?.type === 'always'

    if (!isCreate && !isUpdate) return xform

    // Build case data element
    let caseChildren = ''
    const binds: string[] = []

    if (isCreate) {
      caseChildren += '\n            <create>\n              <case_type/>\n              <case_name/>\n              <owner_id/>\n            </create>'
      binds.push(`      <bind nodeset="/data/case/create/case_type" calculate="'${caseType}'"/>`)
      const namePath = openCase.name_update?.question_path || '/data/name'
      binds.push(`      <bind nodeset="/data/case/create/case_name" calculate="${namePath}"/>`)
      binds.push(`      <bind nodeset="/data/case/create/owner_id" calculate="instance('commcaresession')/session/context/userid"/>`)
    }

    if (isUpdate && updateCase.update) {
      const props = Object.keys(updateCase.update)
      if (props.length > 0) {
        const propElements = props.map(p => `              <${p}/>`).join('\n')
        caseChildren += `\n            <update>\n${propElements}\n            </update>`
        for (const [prop, mapping] of Object.entries(updateCase.update)) {
          const qPath = (mapping as any).question_path || `/data/${prop}`
          binds.push(`      <bind nodeset="/data/case/update/${prop}" calculate="${qPath}"/>`)
        }
      }
    }

    const caseBlock = `          <case>${caseChildren}\n          </case>`

    // Insert case block into <data> element (before closing </data>)
    xform = xform.replace(/(<\/data>)/, `\n${caseBlock}\n        $1`)

    // Insert case binds after the last existing <bind>
    const bindStr = binds.join('\n')
    const lastBindIdx = xform.lastIndexOf('</bind>')
    if (lastBindIdx === -1) {
      // No existing binds, insert before <itext> or </model>
      xform = xform.replace(/(<itext>|<\/model>)/, `${bindStr}\n      $1`)
    } else {
      // Find the end of the last bind's line
      const afterLastBind = xform.indexOf('\n', lastBindIdx)
      if (afterLastBind !== -1) {
        xform = xform.substring(0, afterLastBind + 1) + bindStr + '\n' + xform.substring(afterLastBind + 1)
      }
    }

    // Add commcaresession instance if not present
    if (!xform.includes("id=\"commcaresession\"")) {
      xform = xform.replace(
        /(<\/instance>)/,
        `$1\n      <instance id="commcaresession" src="jr://instance/session"/>`
      )
    }

    return xform
  }

  private async packageCcz(files: Record<string, string>, appName: string): Promise<string> {
    const outputDir = join(tmpdir(), 'commcare-forge', randomUUID())
    mkdirSync(outputDir, { recursive: true })

    const cczFileName = `${(appName || 'app').replace(/[^a-zA-Z0-9-_]/g, '_')}.ccz`
    const cczPath = join(outputDir, cczFileName)

    return new Promise((resolve, reject) => {
      const output = createWriteStream(cczPath)
      const archive = archiver('zip', { zlib: { level: 0 } })

      output.on('close', () => resolve(cczPath))
      archive.on('error', (err) => reject(err))

      archive.pipe(output)

      for (const [filePath, content] of Object.entries(files)) {
        archive.append(content, { name: filePath })
      }

      archive.finalize()
    })
  }

  private escapeXml(s: string): string {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;')
  }
}
